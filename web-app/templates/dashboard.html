{% extends "layout.html" %}

{% block title %}Dashboard{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
<style>
    #map {
        height: 100%;
        width: 100%;
        border-radius: 0;
        min-height: 450px;
    }
    .video-container {
        position: relative;
        width: 100%;
        height: 540px;  /* Increased for 720p (16:9 aspect ratio) */
        background-color: #222;
        border-radius: 5px;
        overflow: hidden;
    }
    .video-container video {
        width: 100%;
        height: 100%;
        object-fit: contain;  /* Maintain aspect ratio for 720p */
    }
    .data-card {
        background-color: #2c3034;
        border: 1px solid #495057;
        border-radius: 5px;
    }
    .controls {
        margin-top: 10px;
    }
    
    /* Pulse animation for detection count updates */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    
    /* Detection stats overlay */
    .detection-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 10px;
        padding: 15px;
        min-width: 200px;
        z-index: 10;
    }
    
    .detection-stats-compact {
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    .detection-stat-item {
        text-align: center;
        color: white;
    }
    
    .detection-stat-item i {
        font-size: 1.2rem;
        margin-bottom: 5px;
    }
    
    .detection-stat-item .count {
        font-size: 1.5rem;
        font-weight: bold;
        display: block;
    }
    
    .detection-stat-item .label {
        font-size: 0.7rem;
        opacity: 0.8;
    }
    
    /* Circular video control buttons */
    .video-controls {
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        align-items: center;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 15px;
        border-radius: 25px;
    }
    
    .video-controls .btn {
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border: none;
    }
    
    .video-controls .btn span {
        display: none;
    }
    
    .video-controls .dropdown-toggle {
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    
    .video-controls .dropdown-toggle::after {
        display: none;
    }
    
    /* Analysis & Capture Controls */
    .analysis-controls-wrapper {
        position: absolute;
        bottom: 15px;
        right: 15px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 15px;
        border-radius: 25px;
    }
    
    .analysis-controls {
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
    }
    
    .analysis-controls .btn {
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border: none;
    }
    
    /* Map overlay controls */
    .map-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 1000;
    }
    
    .map-control-group {
        display: flex;
        gap: 5px;
    }
    
    .map-control-group .btn {
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        font-size: 0.8rem;
    }
    
    .map-control-group .form-check {
        margin: 0;
        background: rgba(0, 0, 0, 0.7);
        padding: 6px 8px;
        border-radius: 6px;
    }
    
    .map-control-group .form-check-input {
        margin: 0;
        width: 14px;
        height: 14px;
    }
    
    .map-control-group .form-check-label {
        font-size: 0.75rem;
        margin-left: 4px;
        cursor: pointer;
    }
    
    /* Map wrapper styling */
    .map-wrapper {
        background-color: #2c3034;
        border: 1px solid #495057;
        border-radius: 5px;
        overflow: hidden;
        height: 100%;
        display: flex;
        flex-direction: column;
    }
    
    .map-header {
        background-color: #343a40;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #495057;
    }
    
    .map-header h5 {
        margin: 0;
        color: white;
        font-size: 1.1rem;
    }
    
    .map-container {
        position: relative;
        flex: 1;
        min-height: 450px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid py-4 mt-5">
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h2 class="mb-1">Flight Control Center</h2>
                    <p class="text-muted mb-0">Real-time monitoring and control system</p>
                </div>
                <div class="d-flex gap-3">
                    <button class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>New Mission
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row">
        <!-- Video Stream Panel -->
        <div class="col-lg-8 mb-4">
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="me-4"><i class="fas fa-video me-2"></i> Live Video Feed</h5>
                        <div class="d-flex align-items-center gap-4">
                            <div class="dropdown">
                                <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" id="videoSourceDropdown" data-bs-toggle="dropdown">
                                    <i class="fas fa-camera me-2"></i> Camera Source
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end" id="videoSourceList">
                                    <!-- Device options will be populated by VideoLayoutManager -->
                                </ul>
                            </div>
                            <span class="badge bg-success" id="streamStatus">Ready</span>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="video-container" id="videoContainer">
                        <!-- Detection Stats Overlay -->
                        <div class="detection-overlay">
                            <div class="detection-stats-compact">
                                <div class="detection-stat-item">
                                    <i class="fas fa-male text-success"></i>
                                    <span class="count text-success" id="earthPersonCount">0</span>
                                    <div class="label">ƒê·∫•t li·ªÅn</div>
                                </div>
                                <div class="detection-stat-item">
                                    <i class="fas fa-swimmer text-warning"></i>
                                    <span class="count text-warning" id="seaPersonCount">0</span>
                                    <div class="label">Bi·ªÉn</div>
                                </div>
                                <div class="detection-stat-item">
                                    <i class="fas fa-users text-info"></i>
                                    <span class="count text-info" id="totalPersonCount">0</span>
                                    <div class="label">T·ªïng s·ªë</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="video-grid" id="videoGrid">
                            <!-- Video cells will be dynamically created by VideoLayoutManager -->
                        </div>
                        <div class="video-controls">
                            <button id="startStream" class="btn btn-success" title="Start Stream">
                                <i class="fas fa-play"></i>
                            </button>
                            <button id="stopStream" class="btn btn-danger" title="Stop Stream">
                                <i class="fas fa-stop"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn btn-secondary dropdown-toggle" type="button" id="viewLayoutDropdown" data-bs-toggle="dropdown" title="Layout Options">
                                    <i class="fas fa-th-large"></i>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-dark" id="viewLayoutList">
                                    <li><a class="dropdown-item active" href="#" data-layout="single"><i class="fas fa-square me-2"></i>Single View</a></li>
                                    <li><a class="dropdown-item" href="#" data-layout="grid"><i class="fas fa-th me-2"></i>Grid View</a></li>
                                    <!-- Dynamic device-specific layout options will be added here -->
                                </ul>
                            </div>
                            <button id="fullscreenBtn" class="btn btn-light" title="Fullscreen">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                        
                        <!-- Analysis & Capture Controls -->
                        <div class="analysis-controls-wrapper">
                            <div class="analysis-controls">
                                <button class="btn btn-info position-relative" id="btnEmergencyRecord" onclick="triggerEmergencyRecording()" title="AI Emergency Recording">
                                    <i class="fas fa-microphone"></i>
                                    <span class="badge bg-warning text-dark position-absolute top-0 start-100 translate-middle">AI</span>
                                </button>
                                <button id="captureImage" class="btn btn-primary position-relative" title="AI Capture Image">
                                    <i class="fas fa-camera"></i>
                                    <span class="badge bg-warning text-dark position-absolute top-0 start-100 translate-middle">AI</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- GPS Map Panel -->
        <div class="col-lg-4 mb-4">
            <div class="map-wrapper">
                <div class="map-header">
                    <h5><i class="fas fa-map-marker-alt"></i> Flight Tracking</h5>
                </div>
                <div class="map-container">
                    <div id="map"></div>
                        <div class="map-overlay">
                            <div class="map-control-group">
                                <button class="btn btn-dark btn-sm" onclick="centerMap()">
                                    <i class="fas fa-crosshairs"></i>
                                </button>
                                <button class="btn btn-dark btn-sm" onclick="toggleMapLayer()">
                                    <i class="fas fa-layer-group"></i>
                                </button>
                            </div>
                            <div class="map-control-group">
                                <button class="btn btn-dark btn-sm" onclick="zoomIn()">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <button class="btn btn-dark btn-sm" onclick="zoomOut()">
                                    <i class="fas fa-minus"></i>
                                </button>
                            </div>
                            <div class="map-control-group">
                                <div class="form-check form-switch">
                                    <input class="form-check-input" type="checkbox" id="showDrone" checked>
                                    <label class="form-check-label text-white small" for="showDrone">
                                        <i class="fas fa-drone me-1"></i>Drone
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row">
        <!-- GPS Data Panel -->
        <div class="col-lg-12 mb-4">
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5><i class="fas fa-satellite"></i> GPS Telemetry</h5>
                        <div class="d-flex align-items-center gap-3">
                            <div class="btn-group btn-group-sm">
                                <button class="btn btn-outline-light active">
                                    <i class="fas fa-table me-1"></i>Table
                                </button>
                                <button class="btn btn-outline-light">
                                    <i class="fas fa-chart-line me-1"></i>Graph
                                </button>
                            </div>
                            <button class="btn btn-outline-light btn-sm">
                                <i class="fas fa-download me-1"></i>Export
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover table-dark mb-0">
                            <thead>
                                <tr class="text-light">
                                    <th>Device</th>
                                    <th>Latitude</th>
                                    <th>Longitude</th>
                                    <th>Altitude</th>
                                    <th>Speed</th>
                                    <th>Last Update</th>
                                </tr>
                            </thead>
                            <tbody id="gpsDataTable">
                                
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="{{ url_for('static', filename='js/webrtc_client.js') }}"></script>
<script src="{{ url_for('static', filename='js/video-layout.js') }}"></script>
<script>
    // Kh·ªüi t·∫°o k·∫øt n·ªëi Socket.IO v√† g√°n global ƒë·ªÉ video-layout.js d√πng
    window.socket = io();
    
    // Debug: Log socket connection status
    socket.on('connect', function() {
        console.log('‚úÖ Socket.IO connected! ID:', socket.id);
        
        // Test capture_request handler
        console.log('üß™ Testing capture_request emission...');
        
        // Add test function to window for manual testing in console
        window.testCapture = function() {
            console.log('üß™ Manual test capture triggered');
            socket.emit('capture_request', {
                device_id: 'test-device',
                timestamp: new Date().toISOString()
            });
            console.log('‚úÖ Test capture_request emitted');
        };
        console.log('üí° Type window.testCapture() in console to test manually');
    });
    
    socket.on('disconnect', function() {
        console.log('‚ùå Socket.IO disconnected!');
    });
    
    socket.on('connect_error', function(error) {
        console.error('‚ùå Socket.IO connection error:', error);
    });
    
    // Kh·ªüi t·∫°o b·∫£n ƒë·ªì
    let map = L.map('map').setView([21.0285, 105.8542], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Markers cho c√°c thi·∫øt b·ªã
    const markers = {};
    
    // Load danh s√°ch video streams t·ª´ API
    async function loadVideoStreams() {
        try {
            const response = await fetch('/api/video/streams');
            const streams = await response.json();
            
            const videoSourceList = document.getElementById('videoSourceList');
            videoSourceList.innerHTML = ''; // Clear existing items
            
            for (const [deviceId, stream] of Object.entries(streams)) {
                const listItem = document.createElement('li');
                const deviceName = stream.device_name || deviceId.charAt(0).toUpperCase() + deviceId.slice(1);
                listItem.innerHTML = `<a class="dropdown-item" href="#" data-device-id="${deviceId}">${deviceName}</a>`;
                videoSourceList.appendChild(listItem);
                
                // Th√™m marker cho b·∫£n ƒë·ªì
                if (!markers[deviceId]) {
                    markers[deviceId] = L.marker([21.0285, 105.8542], {
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: '<div style="background-color: #007bff; width: 15px; height: 15px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [15, 15],
                            iconAnchor: [7, 7]
                        })
                    }).addTo(map).bindPopup(`${deviceName} (${deviceId})`);
                }
            }
            
            // Th√™m event listeners cho c√°c item m·ªõi
            document.querySelectorAll('#videoSourceList a').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    const deviceId = this.getAttribute('data-device-id');
                    const deviceName = this.textContent;
                    document.getElementById('videoSourceDropdown').textContent = deviceName;
                    
                    // D·ª´ng stream hi·ªán t·∫°i n·∫øu c√≥
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnection = null;
                        videoElement.srcObject = null;
                    }
                    
                    // B·∫Øt ƒë·∫ßu stream m·ªõi
                    startWebRTC(deviceId);
                });
            });
            
            // Set device ƒë·∫ßu ti√™n l√†m m·∫∑c ƒë·ªãnh
            const firstDevice = document.querySelector('#videoSourceList a[data-device-id]');
            if (firstDevice && !document.getElementById('videoSourceDropdown').getAttribute('data-device-id')) {
                const deviceId = firstDevice.getAttribute('data-device-id');
                const deviceName = firstDevice.textContent;
                document.getElementById('videoSourceDropdown').textContent = deviceName;
                document.getElementById('videoSourceDropdown').setAttribute('data-device-id', deviceId);
            }
            
        } catch (error) {
            console.error('L·ªói khi load danh s√°ch video streams:', error);
        }
    }
    
    // Load danh s√°ch GPS data t·ª´ API
    async function loadGPSData() {
        try {
            const response = await fetch('/api/gps');
            const gpsData = await response.json();
            
            const gpsTable = document.getElementById('gpsDataTable');
            gpsTable.innerHTML = ''; // Clear existing rows
            
            for (const [deviceId, data] of Object.entries(gpsData)) {
                const row = document.createElement('tr');
                const deviceName = data.device_name || deviceId.charAt(0).toUpperCase() + deviceId.slice(1);
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                
                row.innerHTML = `
                    <td>${deviceName}</td>
                    <td id="${deviceId}-lat">${data.latitude.toFixed(6)}</td>
                    <td id="${deviceId}-lng">${data.longitude.toFixed(6)}</td>
                    <td id="${deviceId}-alt">${data.altitude}m</td>
                    <td id="${deviceId}-speed">${data.speed} km/h</td>
                    <td id="${deviceId}-time">${timestamp}</td>
                `;
                gpsTable.appendChild(row);
                
                // C·∫≠p nh·∫≠t marker tr√™n b·∫£n ƒë·ªì
                if (markers[deviceId]) {
                    markers[deviceId].setLatLng([data.latitude, data.longitude]);
                    markers[deviceId].getPopup().setContent(`${deviceName}<br>ƒê·ªô cao: ${data.altitude}m<br>T·ªëc ƒë·ªô: ${data.speed} km/h`);
                }
            }
        } catch (error) {
            console.error('L·ªói khi load GPS data:', error);
        }
    }
    
    // Map control functions
    function centerMap() {
        // Center the map on the active drone
        const activeDrone = Object.values(markers)[0];
        if (activeDrone) {
            map.setView(activeDrone.getLatLng(), map.getZoom());
        }
    }

    function toggleMapLayer() {
        // Toggle between different map layers (satellite, terrain, etc.)
        const currentLayer = map.hasLayer(satelliteLayer);
        if (currentLayer) {
            map.removeLayer(satelliteLayer);
            map.addLayer(streetLayer);
        } else {
            map.removeLayer(streetLayer);
            map.addLayer(satelliteLayer);
        }
    }

    function zoomIn() {
        map.setZoom(map.getZoom() + 1);
    }

    function zoomOut() {
        map.setZoom(map.getZoom() - 1);
    }

    // Initialize map layers
    const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });

    // Set default layer
    streetLayer.addTo(map);

    // Load d·ªØ li·ªáu ban ƒë·∫ßu
    loadVideoStreams();
    loadGPSData();
    // Update flight time display every second
    function updateFlightTime() {
        const el = document.getElementById('flightTime');
        if (!el) return;
        const now = new Date();
        // Use locale time string for human-readable format
        el.textContent = now.toLocaleTimeString();
    }
    updateFlightTime();
    setInterval(updateFlightTime, 1000);
    
    // Initialize VideoLayoutManager
    if (typeof VideoLayoutManager !== 'undefined') {
        console.log('üé• Initializing VideoLayoutManager...');
        window.videoLayoutManager = new VideoLayoutManager();
        console.log('‚úÖ VideoLayoutManager initialized');
    } else {
        console.error('‚ùå VideoLayoutManager class not found');
    }
    
    // Listen for detection updates via Socket.IO
    socket.on('detection_update', function(data) {
        console.log('üìä Received detection update:', data);
        
        // Update person counts with animation
        const earthEl = document.getElementById('earthPersonCount');
        const seaEl = document.getElementById('seaPersonCount');
        const totalEl = document.getElementById('totalPersonCount');
        
        if (!earthEl || !seaEl || !totalEl) {
            console.error('‚ùå Detection count elements not found!');
            return;
        }
        
        const earthCount = data.earth_person_count || 0;
        const seaCount = data.sea_person_count || 0;
        const totalCount = data.person_count || 0;
        
        // Update with visual feedback
        earthEl.textContent = earthCount;
        seaEl.textContent = seaCount;
        totalEl.textContent = totalCount;
        
        console.log(`‚úÖ Updated UI: Earth=${earthCount}, Sea=${seaCount}, Total=${totalCount}`);
        
        // Add pulse effect when count changes
        if (totalCount > 0) {
            earthEl.style.animation = 'pulse 0.3s';
            seaEl.style.animation = 'pulse 0.3s';
            totalEl.style.animation = 'pulse 0.3s';
            setTimeout(() => {
                earthEl.style.animation = '';
                seaEl.style.animation = '';
                totalEl.style.animation = '';
            }, 300);
        }
    });
    
    // Test function to manually trigger detection update
    function testDetectionUpdate() {
        console.log('üß™ Testing detection update...');
        
        // Method 1: Call server test endpoint
        fetch('/api/test_detection', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            console.log('‚úÖ Server test response:', data);
        })
        .catch(error => {
            console.error('‚ùå Server test failed:', error);
        });
        
        // Method 2: Also test local update
        const testData = {
            device_id: 'test',
            earth_person_count: Math.floor(Math.random() * 10),
            sea_person_count: Math.floor(Math.random() * 10),
            person_count: 0,
            timestamp: new Date().toISOString()
        };
        testData.person_count = testData.earth_person_count + testData.sea_person_count;
        
        // Update UI directly for immediate feedback
        document.getElementById('earthPersonCount').textContent = testData.earth_person_count;
        document.getElementById('seaPersonCount').textContent = testData.sea_person_count;
        document.getElementById('totalPersonCount').textContent = testData.person_count;
        
        console.log('‚úÖ Local test data:', testData);
    }
    
    // X·ª≠ l√Ω khi nh·∫≠n d·ªØ li·ªáu GPS m·ªõi
    socket.on('gps_update', function(data) {
        console.log('Nh·∫≠n d·ªØ li·ªáu GPS:', data);
        
        const deviceId = data.device_id;
        const deviceName = data.device_name || deviceId.charAt(0).toUpperCase() + deviceId.slice(1);
        const timestamp = new Date(data.timestamp).toLocaleTimeString();
        
        // Ki·ªÉm tra xem device ƒë√£ c√≥ trong b·∫£ng ch∆∞a
        let row = document.getElementById(`${deviceId}-lat`);
        if (!row) {
            // Th√™m device m·ªõi v√†o b·∫£ng
            const gpsTable = document.getElementById('gpsDataTable');
            const newRow = document.createElement('tr');
            newRow.innerHTML = `
                <td>${deviceName}</td>
                <td id="${deviceId}-lat">${data.latitude.toFixed(6)}</td>
                <td id="${deviceId}-lng">${data.longitude.toFixed(6)}</td>
                <td id="${deviceId}-alt">${data.altitude}m</td>
                <td id="${deviceId}-speed">${data.speed} km/h</td>
                <td id="${deviceId}-time">${timestamp}</td>
            `;
            gpsTable.appendChild(newRow);
            
            // Th√™m marker cho b·∫£n ƒë·ªì n·∫øu ch∆∞a c√≥
            if (!markers[deviceId]) {
                markers[deviceId] = L.marker([data.latitude, data.longitude], {
                    icon: L.divIcon({
                        className: 'custom-div-icon',
                        html: '<div style="background-color: #007bff; width: 15px; height: 15px; border-radius: 50%; border: 2px solid white;"></div>',
                        iconSize: [15, 15],
                        iconAnchor: [7, 7]
                    })
                }).addTo(map).bindPopup(`${deviceName} (${deviceId})`);
            }
        } else {
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu hi·ªán c√≥
            document.getElementById(`${deviceId}-lat`).textContent = data.latitude.toFixed(6);
            document.getElementById(`${deviceId}-lng`).textContent = data.longitude.toFixed(6);
            document.getElementById(`${deviceId}-alt`).textContent = `${data.altitude}m`;
            document.getElementById(`${deviceId}-speed`).textContent = `${data.speed} km/h`;
            document.getElementById(`${deviceId}-time`).textContent = timestamp;
        }
        
        // C·∫≠p nh·∫≠t marker tr√™n b·∫£n ƒë·ªì
        if (markers[deviceId]) {
            markers[deviceId].setLatLng([data.latitude, data.longitude]);
            markers[deviceId].getPopup().setContent(`${deviceName}<br>ƒê·ªô cao: ${data.altitude}m<br>T·ªëc ƒë·ªô: ${data.speed} km/h`);
        }
    });
    
    // X·ª≠ l√Ω WebRTC
    const startStreamButton = document.getElementById('startStream');
    const stopStreamButton = document.getElementById('stopStream');
    const streamStatus = document.getElementById('streamStatus');
    const captureButton = document.getElementById('captureImage');
    const fullscreenButton = document.getElementById('fullscreenBtn');
    
    let peerConnection;
    let currentVideoElement = null;
    
    // Kh·ªüi t·∫°o k·∫øt n·ªëi WebRTC
    async function startWebRTC(deviceId) {
        try {
            console.log('startWebRTC called with deviceId:', deviceId);
            
            // Check if we already have an active connection
            if (peerConnection && peerConnection.connectionState !== 'closed' && peerConnection.connectionState !== 'failed') {
                console.log('WebRTC connection already exists, closing it first');
                peerConnection.close();
                peerConnection = null;
            }
            
            streamStatus.textContent = 'ƒêang k·∫øt n·ªëi...';
            streamStatus.className = 'badge bg-warning';
            
            // T·∫°o peer connection
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    { urls: 'turn:relay1.expressturn.com:3480', username: '000000002076929768', credential: 'glxmCqGZVm2WqKrB/EXZsf2SZGc=' }
                ]
            };
            
            peerConnection = new RTCPeerConnection(configuration);
            
            // Monitor connection state
            peerConnection.onconnectionstatechange = () => {
                console.log('üîó PeerConnection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    startStreamButton.disabled = true;
                    stopStreamButton.disabled = false;
                    streamStatus.textContent = 'ƒêang ph√°t';
                    streamStatus.className = 'badge bg-success';
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'closed') {
                    startStreamButton.disabled = false;
                    stopStreamButton.disabled = true;
                    streamStatus.textContent = 'Ng·∫Øt k·∫øt n·ªëi';
                    streamStatus.className = 'badge bg-danger';
                }
            };
            
            // Monitor ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                console.log('üßä ICE connection state:', peerConnection.iceConnectionState);
                console.log('üîç ICE gathering state:', peerConnection.iceGatheringState);
            };
            
            // Monitor ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidateType = event.candidate.candidate.split(' ')[7] || 'unknown';
                    console.log('üì§ Sending ICE candidate:', candidateType, event.candidate.candidate);
                    socket.emit('webrtc_ice_candidate', {
                        device_id: deviceId,
                        candidate: event.candidate
                    });
                } else {
                    console.log('üì§ ICE candidate gathering completed');
                }
            };
            
            // X·ª≠ l√Ω khi nh·∫≠n ƒë∆∞·ª£c track
            peerConnection.ontrack = event => {
                console.log('üé• Received video track:', event.track.kind, event.track.id);
                console.log('üé• Track streams:', event.streams.length);
                if (event.streams[0]) {
                    console.log('üé• Stream ID:', event.streams[0].id);
                    console.log('üé• Stream tracks:', event.streams[0].getTracks().length);
                }
                
                // Get the active video element from VideoLayoutManager
                if (window.videoLayoutManager) {
                    const activeVideoElement = window.videoLayoutManager.getActiveVideoElement();
                    if (activeVideoElement) {
                        console.log('üé• Setting video srcObject to active element');
                        activeVideoElement.srcObject = event.streams[0];
                        currentVideoElement = activeVideoElement;
                        
                        // Try to play the video
                        activeVideoElement.play().catch(e => {
                            console.warn('üé• Could not autoplay video:', e);
                        });
                        
                        // Monitor video element for loading issues
                        activeVideoElement.onloadedmetadata = () => {
                            console.log('üé• Video metadata loaded:', activeVideoElement.videoWidth, 'x', activeVideoElement.videoHeight);
                        };
                        activeVideoElement.oncanplay = () => {
                            console.log('üé• Video can play');
                        };
                        activeVideoElement.onerror = (e) => {
                            console.error('üé• Video element error:', e);
                        };
                    } else {
                        console.warn('No active video element found');
                    }
                } else {
                    console.warn('VideoLayoutManager not available');
                }
                
                streamStatus.textContent = 'ƒêang ph√°t';
                streamStatus.className = 'badge bg-success';
            };
            
            // G·ª≠i y√™u c·∫ßu b·∫Øt ƒë·∫ßu stream ƒë·∫øn server
            console.log('Requesting stream start for device:', deviceId);
            socket.emit('start_webrtc', {
                device_id: deviceId
            });
            
            // Set a timeout to re-enable buttons if connection doesn't establish
            setTimeout(() => {
                if (peerConnection && peerConnection.connectionState !== 'connected') {
                    console.log('WebRTC connection timeout, re-enabling buttons');
                    startStreamButton.disabled = false;
                    stopStreamButton.disabled = true;
                    streamStatus.textContent = 'Timeout';
                    streamStatus.className = 'badge bg-warning';
                }
            }, 30000); // 30 second timeout
            
        } catch (error) {
            console.error('L·ªói khi kh·ªüi t·∫°o WebRTC:', error);
            streamStatus.textContent = 'L·ªói k·∫øt n·ªëi';
            streamStatus.className = 'badge bg-danger';
            startStreamButton.disabled = false;
            stopStreamButton.disabled = true;
        }
    }

    // Capture high-quality image directly from drone camera (independent of WebRTC)
    async function captureCurrentFrame() {
        console.log('üé¨ captureCurrentFrame() called');
        try {
            // Get device ID from current video source
            const deviceId = document.getElementById('videoSourceDropdown').getAttribute('data-device-id') || 'drone-camera';
            
            console.log('üì∏ Device ID:', deviceId);
            console.log('üì∏ Socket connected:', socket.connected);
            console.log('üì∏ Sending capture request for device:', deviceId);
            
            // Disable button while processing
            captureButton.disabled = true;
            const originalHTML = captureButton.innerHTML;
            captureButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>ƒêang ch·ª•p...</span>';
            
            // Update status
            streamStatus.textContent = 'ƒêang ch·ª•p...';
            streamStatus.className = 'badge bg-warning';
            
            // Emit capture request via Socket.IO
            socket.emit('capture_request', {
                device_id: deviceId,
                timestamp: new Date().toISOString()
            });
            
            // Re-enable button after 3 seconds
            setTimeout(() => {
                captureButton.disabled = false;
                captureButton.innerHTML = originalHTML;
            }, 3000);
            
        } catch (err) {
            console.error('‚ùå Capture error:', err);
            captureButton.disabled = false;
            streamStatus.textContent = 'L·ªói ch·ª•p h√¨nh';
            streamStatus.className = 'badge bg-danger';
        }
    }
    
    // Fallback method: capture from video element (lower quality)
    async function captureFromVideoElement() {
        try {
            let videoEl = currentVideoElement;
            if (!videoEl && window.videoLayoutManager) videoEl = window.videoLayoutManager.getActiveVideoElement();
            if (!videoEl || !videoEl.srcObject) {
                const anyVideo = document.querySelector('#videoGrid video');
                if (!anyVideo || !anyVideo.srcObject) {
                    streamStatus.textContent = 'Kh√¥ng c√≥ video';
                    streamStatus.className = 'badge bg-danger';
                    return;
                }
                videoEl = anyVideo;
            }

            const width = videoEl.videoWidth || 640;
            const height = videoEl.videoHeight || 480;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoEl, 0, 0, width, height);

            canvas.toBlob(async (blob) => {
                if (!blob) return;
                const form = new FormData();
                const deviceId = document.getElementById('videoSourceDropdown').getAttribute('data-device-id') || 'drone-camera';
                form.append('image', blob, 'capture.jpg');
                form.append('device_id', deviceId);

                try {
                    const resp = await fetch('/api/capture', { method: 'POST', body: form });
                    if (resp.ok) {
                        streamStatus.textContent = '·∫¢nh ƒë√£ l∆∞u (fallback)';
                        streamStatus.className = 'badge bg-success';
                    }
                } catch (err) {
                    console.error('Fallback capture error:', err);
                }
            }, 'image/jpeg', 0.95);
        } catch (err) {
            console.error('Fallback capture error:', err);
        }
    }

    // Toggle fullscreen on the video container
    function toggleFullscreen() {
        const container = document.getElementById('videoContainer');
        if (!container) return;
        if (document.fullscreenElement) {
            document.exitFullscreen().catch(e => console.warn('exitFullscreen failed', e));
        } else {
            container.requestFullscreen?.().catch(e => console.warn('requestFullscreen failed', e));
        }
    }
    
    // X·ª≠ l√Ω khi nh·∫≠n ƒë∆∞·ª£c offer t·ª´ server (t·ª´ drone)
    socket.on('webrtc_offer', async function(data) {
        try {
            console.log('Received offer from drone:', data.device_id);
            
            // N·∫øu ch∆∞a c√≥ peer connection ho·∫∑c ƒëang k·∫øt n·ªëi v·ªõi device kh√°c, t·∫°o m·ªõi
            const currentDeviceId = document.getElementById('videoSourceDropdown').getAttribute('data-device-id');
            if (!peerConnection || data.device_id !== currentDeviceId) {
                console.log('Offer not for current device or no peer connection, ignoring');
                return;
            }
            
            // Ki·ªÉm tra signaling state
            if (peerConnection.signalingState !== 'stable' && peerConnection.signalingState !== 'have-local-offer') {
                console.log('PeerConnection not in correct state for offer, current state:', peerConnection.signalingState);
                return;
            }
            
            const remoteDesc = new RTCSessionDescription({
                sdp: data.sdp,
                type: data.type
            });
            
            await peerConnection.setRemoteDescription(remoteDesc);
            console.log('Set remote description (offer) successfully');
            
            // T·∫°o answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            // G·ª≠i answer v·ªÅ server
            socket.emit('webrtc_answer', {
                device_id: data.device_id,
                sdp: peerConnection.localDescription.sdp,
                type: peerConnection.localDescription.type
            });
            
            console.log('Sent answer to server');
        } catch (error) {
            console.error('L·ªói khi x·ª≠ l√Ω offer:', error);
        }
    });
    
    // X·ª≠ l√Ω khi nh·∫≠n ƒë∆∞·ª£c answer t·ª´ server (kh√¥ng n√™n x·∫£y ra v√¨ drone l√† offerer)
    socket.on('webrtc_answer', async function(data) {
        console.log('Received unexpected answer - drone should be offerer, ignoring');
    });
    
    // X·ª≠ l√Ω khi nh·∫≠n ƒë∆∞·ª£c ICE candidate t·ª´ server
    socket.on('webrtc_ice_candidate', async function(data) {
        if (!peerConnection) return;
        
        try {
            // data.candidate should be the ICE candidate object with candidate, sdpMid, sdpMLineIndex
            if (data.candidate) {
                console.log('üì® Received ICE candidate from drone:', data.candidate.candidate);
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('‚úÖ Added ICE candidate from drone');
            } else {
                console.log('üì® Received ICE gathering complete from drone');
            }
        } catch (error) {
            console.error('‚ùå L·ªói khi x·ª≠ l√Ω ICE candidate:', error);
        }
    });
    
    // S·ª± ki·ªán khi nh·∫•n n√∫t b·∫Øt ƒë·∫ßu stream
    startStreamButton.addEventListener('click', function() {
        // Check if already connecting or connected
        if (peerConnection && peerConnection.connectionState !== 'closed' && peerConnection.connectionState !== 'failed') {
            console.log('WebRTC already active, ignoring start request');
            return;
        }
        
        const selectedDevice = document.getElementById('videoSourceDropdown').getAttribute('data-device-id') || (document.querySelector('#videoSourceList a[data-device-id]')?.getAttribute('data-device-id')) || 'Drone1';
        console.log('Starting WebRTC for device:', selectedDevice);
        startWebRTC(selectedDevice);
        startStreamButton.disabled = true;
        stopStreamButton.disabled = false;
    });
    
    // S·ª± ki·ªán khi nh·∫•n n√∫t d·ª´ng stream
    stopStreamButton.addEventListener('click', function() {
        const deviceId = document.getElementById('videoSourceDropdown').getAttribute('data-device-id') || (document.querySelector('#videoSourceList a[data-device-id]')?.getAttribute('data-device-id')) || 'Drone1';
        // Tell server/drone to stop streaming
        console.log('Requesting stream stop for device:', deviceId);
        socket.emit('stop_webrtc', { device_id: deviceId });

        if (peerConnection) {
            try { peerConnection.close(); } catch (e) { console.warn('close pc', e); }
            peerConnection = null;
        }

        if (currentVideoElement) {
            currentVideoElement.srcObject = null;
            currentVideoElement = null;
        }

        streamStatus.textContent = 'ƒê√£ d·ª´ng';
        streamStatus.className = 'badge bg-secondary';
        startStreamButton.disabled = false;
        stopStreamButton.disabled = true;
    });

    // Capture button handler
    if (captureButton) {
        console.log('‚úÖ Found capture button:', captureButton);
        captureButton.addEventListener('click', function(event) {
            console.log('üîò Capture button clicked! Event:', event);
            alert('Capture button clicked!');
            captureCurrentFrame();
        });
        console.log('‚úÖ Capture button event listener registered');
    } else {
        console.error('‚ùå Capture button not found! Searching for it...');
        const allButtons = document.querySelectorAll('button');
        console.log('All buttons on page:', allButtons);
        allButtons.forEach(btn => {
            if (btn.id) console.log('Button ID:', btn.id);
        });
    }

    // Fullscreen button handler
    fullscreenButton.addEventListener('click', function() {
        toggleFullscreen();
    });
    
    // X·ª≠ l√Ω khi ch·ªçn ngu·ªìn video
    // Handle video layout switching
    document.addEventListener('click', function(e) {
        if (e.target.closest('#viewLayoutList a')) {
            e.preventDefault();
            const layout = e.target.closest('a').dataset.layout;
            if (window.videoLayoutManager) {
                window.videoLayoutManager.switchLayout(layout);
                
                // Update active state in dropdown
                document.querySelectorAll('#viewLayoutList a').forEach(a => {
                    a.classList.remove('active');
                });
                e.target.closest('a').classList.add('active');
            }
        } else if (e.target.matches('#videoSourceList a')) {
            e.preventDefault();
            const deviceId = e.target.getAttribute('data-device-id');
            const deviceName = e.target.textContent;
            const dropdown = document.getElementById('videoSourceDropdown');
            dropdown.textContent = deviceName;
            dropdown.setAttribute('data-device-id', deviceId);
            
            // D·ª´ng stream hi·ªán t·∫°i n·∫øu c√≥
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                if (currentVideoElement) {
                    currentVideoElement.srcObject = null;
                    currentVideoElement = null;
                }
            }
            
            // B·∫Øt ƒë·∫ßu stream m·ªõi
            startWebRTC(deviceId);
        }
    });
    
    // X·ª≠ l√Ω khi thi·∫øt b·ªã ƒë∆∞·ª£c th√™m m·ªõi
    socket.on('video_device_added', function(data) {
        console.log('Thi·∫øt b·ªã video m·ªõi:', data);
        
        const deviceId = data.device_id;
        const deviceName = data.device_name || deviceId.charAt(0).toUpperCase() + deviceId.slice(1);
        
        // Th√™m v√†o dropdown video source
        const videoSourceList = document.getElementById('videoSourceList');
        let existingItem = videoSourceList.querySelector(`[data-device-id="${deviceId}"]`);
        
        if (!existingItem) {
            const listItem = document.createElement('li');
            listItem.innerHTML = `<a class="dropdown-item" href="#" data-device-id="${deviceId}">${deviceName}</a>`;
            videoSourceList.appendChild(listItem);
            
            // N·∫øu l√† device ƒë·∫ßu ti√™n, set l√†m m·∫∑c ƒë·ªãnh
            const dropdown = document.getElementById('videoSourceDropdown');
            if (!dropdown.getAttribute('data-device-id')) {
                dropdown.textContent = deviceName;
                dropdown.setAttribute('data-device-id', deviceId);
            }
        }
        
        // Th√™m v√†o b·∫£ng GPS n·∫øu ch∆∞a c√≥
        let gpsRow = document.getElementById(`${deviceId}-lat`);
        if (!gpsRow) {
            const gpsTable = document.getElementById('gpsDataTable');
            const newRow = document.createElement('tr');
            newRow.innerHTML = `
                <td>${deviceName}</td>
                <td id="${deviceId}-lat">--</td>
                <td id="${deviceId}-lng">--</td>
                <td id="${deviceId}-alt">--</td>
                <td id="${deviceId}-speed">--</td>
                <td id="${deviceId}-time">--</td>
            `;
            gpsTable.appendChild(newRow);
        }
        
        // Th√™m marker cho b·∫£n ƒë·ªì n·∫øu ch∆∞a c√≥
        if (!markers[deviceId]) {
            markers[deviceId] = L.marker([21.0285, 105.8542], {
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: '<div style="background-color: #007bff; width: 15px; height: 15px; border-radius: 50%; border: 2px solid white;"></div>',
                    iconSize: [15, 15],
                    iconAnchor: [7, 7]
                })
            }).addTo(map).bindPopup(`${deviceName} (${deviceId})`);
        }
    });
    
    // Listen for capture success
    socket.on('capture_success', function(data) {
        console.log('‚úÖ Capture success:', data);
        
        // Update status
        streamStatus.textContent = 'Ch·ª•p h√¨nh th√†nh c√¥ng!';
        streamStatus.className = 'badge bg-success';
        
        // Show notification
        if (window.Notification && Notification.permission === 'granted') {
            new Notification('Ch·ª•p h√¨nh th√†nh c√¥ng', {
                body: `Capture ID: ${data.capture_id}\nƒêang ph√¢n t√≠ch AI...`,
                icon: '/static/images/camera-icon.png'
            });
        }
        
        // Reset status after 3 seconds
        setTimeout(() => {
            streamStatus.textContent = 'Ready';
            streamStatus.className = 'badge bg-success';
        }, 3000);
    });
    
    // Listen for capture error
    socket.on('capture_error', function(data) {
        console.error('‚ùå Capture error:', data);
        
        // Update status
        streamStatus.textContent = 'L·ªói: ' + data.error;
        streamStatus.className = 'badge bg-danger';
        
        // Re-enable button
        captureButton.disabled = false;
        captureButton.innerHTML = '<i class="fas fa-camera"></i> <span>Capture</span>';
        
        // Reset status after 5 seconds
        setTimeout(() => {
            streamStatus.textContent = 'Ready';
            streamStatus.className = 'badge bg-success';
        }, 5000);
    });
    
    // Trigger emergency recording
    function triggerEmergencyRecording() {
        const button = document.getElementById('btnEmergencyRecord');
        if (!button) return;
        
        button.disabled = true;
        const originalHTML = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Recording...';
        
        fetch('/api/voice/trigger-recording', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert('‚úÖ Emergency recording triggered! Check Voice Records in ~20 seconds.');
            } else {
                alert('‚ùå ' + (data.message || 'Failed to trigger recording'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('‚ùå Network error');
        })
        .finally(() => {
            setTimeout(() => {
                button.disabled = false;
                button.innerHTML = originalHTML;
            }, 3000);
        });
    }
    
    // Listen for AI analysis complete
    socket.on('capture_analyzed', function(data) {
        console.log('ü§ñ AI Analysis complete:', data);
        
        // Update status
        streamStatus.textContent = 'Ph√¢n t√≠ch ho√†n t·∫•t!';
        streamStatus.className = 'badge bg-info';
        
        // Update person counts with analyzed data
        if (data.person_count !== undefined) {
            document.getElementById('totalPersonCount').textContent = data.person_count || 0;
        }
        if (data.earth_person_count !== undefined) {
            document.getElementById('earthPersonCount').textContent = data.earth_person_count || 0;
        }
        if (data.sea_person_count !== undefined) {
            document.getElementById('seaPersonCount').textContent = data.sea_person_count || 0;
        }
        
        // Show notification with analyzed image
        if (window.Notification && Notification.permission === 'granted') {
            new Notification('Ph√¢n t√≠ch AI ho√†n t·∫•t', {
                body: `T·ªïng: ${data.person_count || 0} ng∆∞·ªùi\nƒê·∫•t: ${data.earth_person_count || 0}, Bi·ªÉn: ${data.sea_person_count || 0}`,
                icon: '/static/images/ai-icon.png'
            });
        }
        
        // Optional: Display analyzed image in a modal or side panel
        if (data.analyzed_image_url) {
            console.log('üì∏ Analyzed image URL:', data.analyzed_image_url);
            // TODO: You can add code here to display the analyzed image
            // Example: Open in modal, update thumbnail, etc.
        }
        
        // Reset status after 3 seconds
        setTimeout(() => {
            streamStatus.textContent = 'Ready';
            streamStatus.className = 'badge bg-success';
        }, 3000);
    });
</script>
{% endblock %}